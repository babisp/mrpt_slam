#include "mrpt_graphslam_2d/CConnectionManager.h"

#include <nav_msgs/OccupancyGrid.h>
#include <nav_msgs/Path.h>
#include <mrpt_msgs/GraphSlamAgents.h>
#include <mrpt/utils/COutputLogger.h>
#include <mrpt/maps/COccupancyGridMap2D.h>
#include <mrpt_bridge/map.h>

using namespace mrpt::graphslam::detail;
using namespace mrpt_msgs;
using namespace mrpt::maps;
using namespace ros;
using namespace mrpt::utils;
using namespace nav_msgs;
using namespace std;

/**\brief Struct holding a COccupancyGridMap2D (as well as subscribers for
 * updating it) for a specific running GraphSlamAgent instance.
 */
struct TNeighborAgentMapProps
{
	TNeighborAgentMapProps(
			mrpt::utils::COutputLogger* logger_in,
			const GraphSlamAgent& agent_in,
			NodeHandle* nh_in):
		m_logger(logger_in),
		nh(nh_in),
		agent(agent_in),
		queue_size(1),
		has_init_class(false),
		has_setup_comm(false)
	{
		ASSERT_(nh);
		ASSERT_(m_logger);
		m_logger->logFmt(LVL_WARN, "In TNeighborAgentMapProps constructor");

		this->map_topic = "/" + agent.topic_namespace.data + "/" +
			"feedback" + "/" + "gridmap";
		this->robot_trajectory_topic = "/" + agent.topic_namespace.data + "/" +
			"feedback" + "/" + "robot_trajectory";

		cout << "Map topic: " << this->map_topic << endl;
		cout << "Trajectory topic: " << this->robot_trajectory_topic << endl;

		// allocate once, change it afterwards
		map = mrpt::maps::COccupancyGridMap2D::Create();
		has_init_class = true;

	}


	void setupComm() {
		ASSERT_(has_init_class);
		m_logger->logFmt(LVL_WARN, "In TNeighborAgentMapProps::setupComm");
		this->setupSubs();
		has_setup_comm = true;
	}

	void setupSubs() {
		m_logger->logFmt(LVL_WARN, "In TNeighborAgentMapProps::setupSubs");
		this->map_sub  = nh->subscribe<nav_msgs::OccupancyGrid>(
				this->map_topic,
				this->queue_size,
				&TNeighborAgentMapProps::updateGridMap, this);

		this->robot_trajectory_sub  = nh->subscribe<nav_msgs::Path>(
				this->robot_trajectory_topic,
				this->queue_size,
				&TNeighborAgentMapProps::updateRobotTrajectory, this);
	} // end of setupSubs

	/**\brief Callback method to be called when new data in the map topic is
	 * available
	 */
	void updateGridMap(
			const nav_msgs::OccupancyGrid::ConstPtr& nav_gridmap) {
a.push_back(1); // sometimes it segfaults here!
		if (nav_gridmap && map.present()) mrpt_bridge::convert(*nav_gridmap, *map); // sometimes here... 
	} // end of updateGridMap

	/**\brief Callback method to be called when new data in the Estimated
	 * Trajectory topic is available
	 */
	void updateRobotTrajectory(
			const nav_msgs::Path::ConstPtr& nav_robot_traj) {
		cout << "KALINUXTA" << endl;
		// TODO
	}


	ros::NodeHandle* nh;
	/**\brief Pointer to the GraphSlamAgent instance of the neighbor */
	const GraphSlamAgent& agent;
	/**\brief Map generated by the corresponding agent - in MRPT form*/
	COccupancyGridMap2DPtr map;
	/**\name Subscriber instances */
	/**\{ */
	/**\brief Map subscriber instance */
	ros::Subscriber map_sub;
	ros::Subscriber robot_trajectory_sub;
	/**\} */
	/**\name Topic names */
	/**\{ */
	/**\brief Map topic to subscribe and fetch the map from */
	std::string map_topic;
	std::string robot_trajectory_topic;
	/**\} */
	size_t queue_size;
	bool has_init_class;
	bool has_setup_comm;
	mrpt::utils::COutputLogger* m_logger;
	std::vector<int> a;


}; // end of TNeighborAgentMapProps

class CMapMerger
{
public:
	typedef std::vector<TNeighborAgentMapProps*> neighbors_t;

	CMapMerger(
			mrpt::utils::COutputLogger* logger_in,
			ros::NodeHandle* nh_in):
		m_logger(logger_in),
		m_nh(nh_in),
		m_conn_manager(logger_in, nh_in),
		m_queue_size(1)
	{
		ASSERT_(m_nh);

		m_global_ns = "/map_merger";
	
	}
	~CMapMerger() { }
	/**\brief Query and fetch the list of new graphSLAM agents.
	 */
	void updateState() {
		// get the new GraphSlamAgents
		const	GraphSlamAgents& nearby_slam_agents =
			m_conn_manager.getNearbySlamAgents();

		for (GraphSlamAgents::_list_type::const_iterator
				it = nearby_slam_agents.list.begin();
				it != nearby_slam_agents.list.end();
				++it) {
			const GraphSlamAgent& gsa = *it;

			// Is the current GraphSlamAgent already registered?
			auto search = [gsa](const TNeighborAgentMapProps* neighbor) {
				return (neighbor->agent == gsa);
			};
			typename neighbors_t::iterator neighbor_it = find_if(
					m_neighbors.begin(),
					m_neighbors.end(), search);

			if (neighbor_it == m_neighbors.end()) { // current gsa not found, add it

				m_neighbors.push_back(new TNeighborAgentMapProps(m_logger, gsa, m_nh));
				TNeighborAgentMapProps* latest_neighbor = m_neighbors.back();
				latest_neighbor->setupComm();
				m_logger->logFmt(LVL_WARN,
						"Initialized NeighborAgentMapProps instance for agent %s...",
						latest_neighbor->agent.topic_namespace.data.c_str());
			}
		} // end for all fetched GraphSlamAgents

		this->updateMergedMap();
	} // end of updateState

	void updateMergedMap() {
		//m_logger->logFmt(LVL_WARN, "In updateMergedMap.");

		// traverse Neighbor instances - get their nav_msgs::OccupancyGrid maps
	}

private:

	void setupPubs() {
		m_feedback_ns = m_global_ns + "/" + "feedback";
		m_merged_map_topic = m_feedback_ns + "/" + "map"; 

		m_merged_map_pub = m_nh->advertise<OccupancyGrid>(
	 		 	m_merged_map_topic,
	 		 	m_queue_size,
	 		 	/*latch=*/true);

	}

	/**\brief CConnectionManager instance for fetching the running graphSLAM
	 * agents
	 */
	neighbors_t m_neighbors;
	mrpt::utils::COutputLogger* m_logger;
	ros::NodeHandle* m_nh;
	CConnectionManager m_conn_manager;

	ros::Publisher m_merged_map_pub;
	/**\brief Topic namespace under which current node is going to be publishing.
	 */
	std::string m_global_ns;
	/**\brief Topic namespace under which, options that are used during the map
	 * alignment procedure are fetched from
	 */
	std::string m_options_ns;
	std::string m_feedback_ns;
	std::string m_merged_map_topic;
	size_t m_queue_size;

}; // end of CMapMerger


/**\brief Node that fetches the local maps produced by the graphSLAM agents and
 * joins them together using a RANSAC-based map-merging technique
 *
 * Node is to be used for inspecting the overall graphSLAM procedure and
 * present the user with a final version of all the independent maps after
 * merging.
 */
int main(int argc, char **argv)
{
	// init ROS Node
	std::string node_name = "map_merger";
  ros::init(argc, argv, node_name);
	ros::NodeHandle nh;
	ros::Rate loop_rate(10);

	// initialize logger.
	COutputLogger logger;
	logger.setLoggerName(node_name);
	logger.logFmt(LVL_WARN, "Initialized %s node...\n", node_name.c_str());

	CMapMerger map_merger(&logger, &nh);

	while (ros::ok()) {
		map_merger.updateState();
		ros::spinOnce();
		loop_rate.sleep();
	}

	return 0;
}
